#! /usr/bin/env python3
# -*- mode: python -*-

import sys
import json
import os.path
import re
import time
from datetime import datetime, date
import concurrent.futures
from tempfile import mkstemp
import curses

import omdb

logfp = open('epm.log', 'w')
import atexit
atexit.register(logfp.flush)
def log(text):
	text = text.replace('\x1b', r'\e').replace('\a', r'\a').replace('\n', r'\n').replace('\r', r'\r')
	print(text, file=logfp, flush=True)
logfp.write('\n'*10)
logfp.flush()


VERSION = '0.4'
VERSION_DATE = '2021-11-16'

PRG = os.path.basename(sys.argv[0])

default_max_episodes_refresh_age = 2*24*3600
episodes_refreshed_key = 'episodes-refreshed'

series_config_file = os.path.expandvars(f'$HOME/.config/{PRG}/series')
num_config_backups = 10

known_commands = (
	'unseen',
	('list', 'ls'),
	'add',
	'delete',
	'mark',
	('unmark', 'um'),
	'archive',
	'restore',
	'refresh',
	'help'
)
default_command = known_commands[0]

_b = '\x1b[1m'     # bold
_c = '\x1b[33;1m'  # command
_o = '\x1b[34;1m'  # option
_f = '\x1b[2m'     # faint
_n = '\x1b[m'      # normal

def main(args):

	if args and args[0] == 'ui':
		return ui_run()

	command = None
	command_args = []
	options = {
		'max-age': default_max_episodes_refresh_age,
	}

	def resolve_cmd(name):
		matching = []

		if name.startswith('.'):
			name = name[1:]

			for cmd in known_commands:
				if isinstance(cmd, str):
					if name == cmd:
						return cmd
					if cmd.startswith(name):
						matching.append(cmd)
				elif isinstance(cmd, tuple):
					if name in cmd:
						return cmd[0]
					if [c.startswith(name) for c in cmd].count(True):
						return cmd[0]

		if len(matching) == 1:
			return matching[0]
		if len(matching) > 1:
			ambiguous_cmd(name, matching)

		# no command matched, use it as argument to the default command
		command_args.append(name)
		return default_command


	while args:
		arg = args.pop(0)

		if arg.startswith('-'):
			if arg == '-r':
				tvpy.enable_refetch(True)
			elif not eat_option(command, arg, args, options):
				bad_opt(arg)
		elif not command:
			command = resolve_cmd(arg)
		else:
			command_args.append(arg)

	if not command:
		command = default_command

	series_config = load_series_config()

	ctl_tty = mk_ctl_tty(sys.stdout.write)

	#ctl_tty('before\a/bghi/hilite\n\a/bgn/after\n')
	#sys.exit(42)

	if command == 'help':
		print_usage()

	else:
		err = cmd_handlers[command](series_config, command_args, options, out=ctl_tty, width=term_width())

	if err is not None:
		print('\x1b[33;1m[\x1b[0;1m%s\x1b[33;1m]\x1b[m %s' % (command, err))
		sys.exit(1)


def eat_option(command, option, args, options):
	if option in ('-h', '--help'):
		if command:
			print_cmd_help(command)
		else:
			print_usage()

	command = command or default_command
	opt_key = get_option_key(command, option)

	if opt_key:
		options[opt_key] = True
	else:
		if command:
			print(f'\x1b[33;1m[{PRG} {command}] Unknown option: {option}\x1b[m', file=sys.stderr)
		else:
			print(f'\x1b[33;1m[{PRG} Option is not implemented: {option}\x1b[m', file=sys.stderr)
		sys.exit(1)

	return True


def cmd_unseen(series_config, args, opts, out=None, detail=True, show_id=True, width=None):
	ind = ' '*7
	if not show_id:
		ind = ' '*3

	refresh_all_episodes(series_config, opts=opts, out=out, width=width)

	series_list = get_series(series_config)
	if not series_list:
		return no_series(series_config)

	#                 idx   year2+pad         dash pad eps                  margin
	max_width = width - 5 - 3 - len('1968')*2 - 1 - 2 - 3 - len('episodes')
	series_unseen = []
	for index, imdb_id, series in series_list:
		_, unseen = seen_unseen_episodes(series)
		if unseen:
			series_unseen.append((index, imdb_id, series, unseen))
			if max_width is None:
				max_width = max(max_width or 0, len(series['title']))

	if not series_unseen:
		return 'Everything has been seen, better add some series!'

	upto_future = 'unseen:future' in opts
	only_started = 'unseen:started' in opts
	only_planned = 'unseen:planned' in opts

	if only_started and only_planned:
		return 'Can\'t specify -s and -p at the same time'

	if args:
		search = re.compile('.*?'.join(re.escape(a.casefold()) for a in ' '.join(args).split()))
		def match_search(series):
			return search.search(series['title'].casefold()) is not None

	else:
		search = None

	#out('\x1b[2mListing ', end='')
	#if only_started:
	#	out('started ', end='')
	#elif only_planned:
	#	out('planned ', end='')
	#out('series with unseen episodes', end='')
	#if search:
	#	out(', matching "%s"' % search.pattern, end='')
	#out('.\x1b[m')

	# TODO: optionally sort series by "earliest" episode in summary mode

	show_series = 0
	total = 0
	total_duration = 0
	#                                                   pad                    margin
	ep_max_width = width - len('       Next: s10e10 ') - 1 - len('1968-04-02') - 1
	if not ep_max_width:
		ep_max_width = max(len(unseen[0]['title']) if unseen else 0 for _, _, _, unseen in series_unseen for ep in unseen)
		ep_max_width = min(ep_max_width, 25)

	for index, imdb_id, series, unseen in series_unseen:

		if search and not match_search(series):
			continue

		has_episodes_seen = len(series.get('seen', {})) > 0

		if only_started and not has_episodes_seen:
			continue
		if only_planned and has_episodes_seen:
			continue

		hilite = (show_series % 2) == 0

		tail = None
		if not search:
			tail = ' \a/dim/%3d episode%s\a//' % (len(unseen), plural(unseen))

		series_printed = False
		def print_series(hilite=False):
			if hilite:
				out('\a/bghi/')

			out(format_series_title(index if show_id else False, series, title_width=max_width))
			if tail:
				out(tail)
			out('\n')

			nonlocal series_printed
			series_printed = True

		if search and detail:
			show_series += 1

			current_season = 0
			for idx, ep in enumerate(unseen):
				if idx > 0:
					out('\n')  # see *1 below
				s, released = format_episode_title('\a/6>/', ep, title_width=ep_max_width, remaining=len(unseen) - idx - 1, today=True)
				if not released:
					break

				if not series_printed:
					print_series(hilite=hilite)

				season = ep['season']
				if season != current_season:
					out('    S%d\r' % season)
					current_season = season

				out(s)
				total += 1
				total_duration += ep.get('runtime', 0)

			if hilite:
				out('\a/bgrst/')

			# last \n  *1: for ansi-esc reasons, 'bgrst' must occur before the \n
			out('\n')

		else:
			s, released = format_episode_title(None, unseen[0], title_width=ep_max_width, today=True, only_released=False)
			if not released:
				#print('not released:', series['title'], unseen[0]['title'])
				continue

			show_series += 1

			if not series_printed:
				print_series(hilite=hilite)
			out(f'{ind}Next: ')
			out(s)
			if hilite:
				#out('\x1b[m')
				out('\a/bgrst/')
			out('\n')

			total += 1
			total_duration += unseen[0].get('runtime', 0)

	# this is wildly incorrect!
	#print(f'\x1b[48;5;235m\x1b[J\rTotal unseen: \x1b[1m{total}\x1b[22;39m episodes  \x1b[2m{fmt_duration(total_duration)}\x1b[22;39m')

def cmd_unseen_help():
	print(f'{_b}Show unseen episodes of series{_n}')
	print(f'Usage: %s {_c}.unseen{_n} <options> <search...>' % PRG)
	print(f'    {_o}#/<IMDb ID>         {_n} Show only specific')
	print(f'    {_o}[<pattern>]         {_n} Show only matching')
	print(f'    {_o}--future            {_n} Also unreleased episodes (max 1)')

	print_cmd_option_help('unseen')


def cmd_list(series_config, args, opts, out=None, width=None):
	refresh_all_episodes(series_config, opts=opts, out=out, width=width)

	series_list = get_series(series_config)

	if not series_list:
		return no_series(series_config)

	# TODO: use 'width'
	max_width = width - 5 - 3 - len('1968')*2 - 1 - 2 - 3 - len('episodes')
	#max_width = max(map(lambda item: len(item[-1]['title']) if 'archived' not in item[-1] else 0, series_list))

	# TODO: print header/columns

	list_all = 'list:all' in opts
	only_archived = 'list:archived' in opts
	only_started = 'list:started' in opts
	only_planned = 'list:planned' in opts

	search = re.compile('.*?'.join(re.escape(a.casefold()) for a in ' '.join(args).split()))
	def match_search(series):
		return search.search(series['title'].casefold()) is not None

	num_shown = 0
	num_archived = 0

	for index, imdb_id, series in series_list:
		archived = 'archived' in series
		if archived:
			num_archived += 1
		if archived and not (list_all or only_archived):
			continue
		if not archived and only_archived:
			continue

		has_episodes_seen = len(series.get('seen', {})) > 0
		if only_started and not has_episodes_seen:
			continue
		if only_planned and has_episodes_seen:
			continue

		if search and not match_search(series):
			continue

		num_shown += 1
		out(format_series_title(index, series, imdb_id=imdb_id, title_width=max_width, gray=archived))
		if archived:
			out('\a/dim/       Archived: %s\a//' % series.get('archived'))
		out(format_seen_status(series, gray=archived))

	out('%d series \a/dim/\a/italic/Total: %d   Archived: %d\a//\n' % (num_shown, len(series_list), num_archived))


def cmd_list_help():
	print(f'{_b}List series{_n}')
	print(f'Usage: %s {_c}.list{_n} <options> [<search...>]' % PRG)
	print(f'    {_o}[<search...>]     {_n} Show only matching series')

	print_cmd_option_help('list')


year_ptn = re.compile(r'^(\d{4})|\((\d{4})\)$')  # 1968 or (1968)

def cmd_add(series_config, args, opts, out=None, width=None):
	if not args:
		return 'required argument missing: <title> / <IMDb ID>'

	args = list(a for a in ' '.join(args).split())
	year = None
	if len(args) >= 2:
		m = year_ptn.match(args[-1])
		if m:
			args.pop()
			year = int(m.group(1) or m.group(2))

	search = ' '.join(args)

	out('- Searching series...')
	hits = omdb.search(search, year=year)
	#print('\r\x1b[J', end='')
	out('\r\a/clr/')
	if not hits:
		out('Nothing found. Try generalizing your search.\n')

	if len(hits) > 1:
		# exclude ones we already have in our config
		already = list(filter(lambda H: H['id'] in series_config, hits))
		hits = list(filter(lambda H: H['id'] not in series_config, hits))

		if already:
			#print('\x1b[2mAlready added: %d\x1b[m' % len(already))
			out('\a/dim/Already added: %d\a//' % len(already))
			for hit in already:
				print_series_title(None, series_config[hit['id']], imdb_id=hit['id'], gray=True)

		max_width = width - 5 - 3 - len('1968')*2 - 1 - 2 - 3 - len('episodes')
		#max_width = max(len(series['title']) for series in hits)

		#print('\x1b[32;1mFound \x1b[0;1m%d\x1b[m \x1b[32;1mseries:\x1b[m' % len(hits))
		out('\a/b/Found %d series:\a//\n\n' % len(hits))
		for idx, hit in enumerate(hits):
			out(format_series_title(idx + 1, hit, imdb_id=hit['id'], title_width=max_width) + '\n')

		out('\n')
		last_num = len(hits)
		while True:
			try:
				selected = input('\x1b[44;97;1mSelect series (1 - %d) to add -->\x1b[m ' % last_num).lstrip('#')
			except (KeyboardInterrupt, EOFError):
				print()
				selected = None

			if not selected:
				return 'Nothing selected, cancelled'

			try:
				selected = int(selected)
				if selected <= 0 or selected > last_num:
					raise ValueError()
			except ValueError:
				print('\x1b[41;97;1m*** Bad selection, try again ***\x1b[m', file=sys.stderr)
				continue

			selected -= 1
			break
	else:
		selected = 0

	hit = hits[selected]
	imdb_id = hit['id']

	if hit['id'] in series_config:
		print('\x1b[33;1mAlready added:\x1b[m')
		for index, series_imdb_id, _ in get_series(series_config):
			if series_imdb_id == imdb_id:
				break
		out(format_series_title(index, series_config[imdb_id], imdb_id=imdb_id) + '\n')
		return

	hit['seen'] = {}
	hit['added'] = now()

	hit.pop('id')
	hit.pop('poster', 0)

	series_config[imdb_id] = hit


	refresh_episodes(imdb_id, series_config)

	# TODO: offer to mark seasons as seen?

	save_series_config(series_config)

	print('\x1b[1mSeries added:\x1b[m  \x1b[2m(series renumbered)\x1b[m')

	for index, series_imdb_id, _ in get_series(series_config):
		if series_imdb_id == imdb_id:
			break

	print_series_title(index, {**hit, 'id': imdb_id}, imdb_id=imdb_id)

def cmd_add_help():
	print(f'{_b}Search for a series and (optionally) add it.{_n}')
	print(f'Usage: %s {_c}.add{_n} <search>' % PRG)
	print(f'    {_o}<title search>{_n}')
	print(f'    {_o}<IMDb ID>{_n}')

	print_cmd_option_help('add')


def cmd_delete(series_config, args, opts, out=None, width=None):
	if not args:
		return 'Required argument missing: #/<IMDb ID>'

	index, imdb_id, series, err = find_series(series_config, args.pop(0))
	if err is not None:
		return err

	del series_config[imdb_id]

	print('\x1b[1mDeleting series:\x1b[m')
	print_series_title(None, series, imdb_id=imdb_id)

	answer = input('\x1b[41;37;1mAre you sure? (can not be undone)\x1b[m [yes/No] ')
	if answer.lower() not in ('y', 'yes'):
		return 'Delete cancelled'

	save_series_config(series_config)

	print('\x1b[1mSeries deleted:\x1b[m \x1b[2m(series renumbered)\x1b[m')
	print_series_title(index, series, imdb_id=imdb_id)

def cmd_delete_help():
	print(f'{_b}Complete remove a series from EPM - non-recoverable!{_n}')
	print(f'Usage: %s {_c}.delete{_n} <# / IMDb ID>' % PRG)
	print(f'    {_o}#/<IMDb ID>{_n}')

	print_cmd_option_help('delete')


def cmd_mark(series_config, args, opts, marking=True, out=None, width=None):
	refresh_all_episodes(series_config, opts=opts, out=out, width=width)

	if not args:
		return 'Required argument missing: #/<IMDb ID>'

	find_id = args.pop(0)

	index, imdb_id, series, err = find_series(series_config, find_id)
	if err is not None:
		return err

	season = None
	episode = None

	ep_ptn = re.compile(r'^\s*(s\d+(-\d+)?)(e\d+(-\d+)?)\s*$')

	# supported syntaxes:
	#   nothing:                                (all seasons, all episodes)
	#   single numbers:              1 2        (season 1, episode 2)
	#   ranges:                      1-2 1-5    (season 1-2, episode 1-5)
	#   season descriptor:           s1         (season 1, all episodes)
	#   "descriptor":                s1e2       (season 1, episode 2)
	#   "descriptor" spaces:         s1 e2      (season 1, episode 2)
	#   "descriptor" ranges:         s1-3e1-4   (season 1-3, episode 1-4)
	#   "descriptor" spaced ranges:  s1-3 e1-4  (season 1-3, episode 1-4)

	if args:
		arg = args.pop(0)

		m = ep_ptn.search(arg)
		if m:
			args = [ m.group(1) ]
			if m.group(3):
				args.append(m.group(3))

		else:
			args.insert(0, arg)

	if args:
		season = args.pop(0)

		try:
			rng = [int(n) for n in season.lower().lstrip('s').split('-')]
			if len(rng) == 2:
				season = range(min(rng), max(rng) + 1)
			else:
				season = (int(rng[0]), )
		except ValueError as ve:
			return f'Bad season number/range: {season}'

	if args:
		episode = args.pop(0)

		try:
			rng = [int(n) for n in episode.lower().lstrip('e').split('-')]
			if len(rng) == 2:
				episode = range(min(rng), max(rng) + 1)
			else:
				episode = (int(rng[0]), )
		except:
			return f'Bad episode number/range: {episode}'

	seen = series.get('seen', {})

	episodes = []
	episodes_duration = 0

	for ep in series.get('episodes', []):
		if (season is None or ep['season'] in season) and (episode is None or ep['episode'] in episode):
			key = _ep_key(ep)

			if marking and key not in seen:
				seen[key] = now()
				episodes.append(ep)
				episodes_duration += ep.get('runtime', 0)

			elif not marking and key in seen:
				del seen[key]
				episodes.append(ep)

	if episodes:
		if marking:
			print('Marked ', end='')
		else:
			print('Unmarked ', end='')

		print(f'\x1b[33;1m{len(episodes)}\x1b[m', end='')
		print(f' episode{plural(episodes)} as seen:  \x1b[0;2m{fmt_duration(episodes_duration)}\x1b[m')
		max_width = max(len(ep['title']) for ep in episodes)

		for ep in episodes:
			print(format_episode_title(series['title'], ep, title_width=max_width)[0])

		save_series_config(series_config)

	else:
		print('\x1b[33;1mNo episodes %smarked\x1b[m' % '' if marking else 'un')


def cmd_mark_help():
	print(f'{_b}Mark a series, season or specific episode as seen.{_n}')
	print(f'Usage: %s {_c}.mark{_n} <# / IMDb ID> [<season / episode specifier>]' % PRG)
	print(f'    {_o}#/<IMDb ID> <season> <episode> {_n} Episodes')
	print(f'    {_o}#/<IMDb ID> <season>           {_n} Seasons')
	print(f'    {_o}#/<IMDb ID>                    {_n} Whole series')
	print('Also support ranges:   > %s .mark 42 1 1-5' % PRG)
	print('And episode specifiers (with ranges): > %s .mark 42 s1e1-5' % PRG)

	print_cmd_option_help('mark')


def cmd_unmark_help():
	print(f'{_b}Unmark a series/season/episode - reverse of .mark command.{_n}')
	print(f'Usage: %s {_c}.unmark{_n} <# / IMDb ID> [<season / episode specifier>]' % PRG)
	print(f'    {_o}#/<IMDb ID> <season> <episode> {_n} Episodes')
	print(f'    {_o}#/<IMDb ID> <season>           {_n} Seasons')
	print(f'    {_o}#/<IMDb ID>                    {_n} Whole series')
	print('Also support ranges:   > %s .mark 42 1 1-5' % PRG)
	print('And episode specifiers (with ranges): > %s .mark 42 s1e1-5' % PRG)

	print_cmd_option_help('unmark')


def cmd_archive(series_config, args, opts, archiving=True, out=None, width=None):
	if not args:
		return 'Required argument missing: #/<IMDb ID>'

	find_id = args.pop(0)

	index, imdb_id, series, err = find_series(series_config, find_id)
	if err is not None:
		return err

	currently_archived = series.get('archived', False) == True

	# TODO: check if all episodes are seen or not?

	if archiving == currently_archived:
		# TODO: better presentation of title
		if archiving:
			return 'Already archived: %s' % series['title']
		else:
			return 'Not archived: %s' % series['title']

	if archiving:
		print('\x1b[1mSeries archived:\x1b[m')
		series['archived'] = True
	else:
		print('\x1b[1mSeries restored:\x1b[m')
		del series['archived']

	print_series_title(index, series, imdb_id=imdb_id)

	save_series_config(series_config)


def cmd_archive_help():
	print(f'{_b}Archving series - hides from normal .list command.{_n}')
	print(f'Usage: %s {_c}.archive{_n} <# / IMDb ID>' % PRG)
	print(f'    {_o}#/<IMDb ID>{_n}')

	print_cmd_option_help('archive')


def cmd_restore_help():
	print(f'{_b}Restore series - reverse of .archive command.{_n}')
	print(f'Usage: %s {_c}.restore{_n} <# / IMDb ID>' % PRG)
	print(f'    {_o}#/<IMDb ID>{_n}')

	print_cmd_option_help('restore')


def cmd_refresh(series_config, args, opts, out=None, width=None):
	refresh_all_episodes(series_config, args, out, width, { **opts, 'max-age': 0 })

def cmd_refresh_help():
	print(f'{_b}Refresh episode data of all non-archived series.{_n}')
	print(f'Usage: %s {_c}.refresh{_n} <# / IMDb ID>' % PRG)
	print(f'    {_o}[#/<IMDb ID>]      {_n} Only specified series')
	print(f'    {_o}[<pattern>]        {_n} Only matching series')

	print_cmd_option_help('refresh')


cmd_handlers = {
	'add': cmd_add,
	'delete': cmd_delete,
	'list': cmd_list,
	'unseen': cmd_unseen,
	'mark': cmd_mark,
	'unmark': lambda *args, **kwargs: cmd_mark(*args, **kwargs, marking=False),
	'archive': cmd_archive,
	'restore': lambda *args, **kwargs: cmd_archive(*args, **kwargs, archiving=False),
	'refresh': cmd_refresh,
}
cmd_help = {
	'add': cmd_add_help,
	'delete': cmd_delete_help,
	'list': cmd_list_help,
	'unseen': cmd_unseen_help,
	'mark': cmd_mark_help,
	'unmark': cmd_unmark_help,
	'archive': cmd_archive_help,
	'restore': cmd_restore_help,
	'refresh': cmd_refresh_help,
}

def find_series(series_config, find_id):
	# if it's an int, search by index, else search by IMDB ID
	try:
		find_id = int(find_id)
	except:
		pass

	for index, imdb_id, series in get_series(series_config):
		if isinstance(find_id, int) and find_id == index:
			return index, imdb_id, series, None
		elif imdb_id == find_id:
			return index, imdb_id, series, None

	return None, None, None, f'Series not found: {find_id}'


def no_series(series_config):
	num_archived = series_num_archived(series_config)
	if num_archived:
		return 'No series [%d archived]. Use: \x1b[1m%s add <title> [<year>]\x1b[m' % (num_archived, PRG)
	else:
		return 'No series. Use: \x1b[1m%s add <title> [<year>]\x1b[m' % PRG


def refresh_episodes(imdb_id, series_config, progress=False):
	if progress:
		print('\x1b[2m(%d / %d) Refreshing episodes for %s...\x1b[m' % (progress[0], progress[1], imdb_id), end='', flush=True)
	elif progress is False:
		print('\x1b[2mRefreshing episodes for %s...\x1b[m' % imdb_id, end='', flush=True)

	episodes = omdb.episodes(imdb_id)
	if progress is not None:
		print('\r\x1b[K', end='', flush=True)

	for ep in episodes:
		transform_episode_info(ep)

	updated = len(episodes) > len(series_config[imdb_id].get('episodes', []))

	series_config[imdb_id]['episodes'] = episodes
	series_config[imdb_id][episodes_refreshed_key] = now()

	return len(episodes)


def refresh_all_episodes(series_config, args=None, opts=None, out=None, width=None):
	opts = opts or {}
	max_age = opts.get('max-age', default_max_episodes_refresh_age)

	now_dt = now_datetime()

	def age(dt):
		return (now_dt - datetime.fromisoformat(dt)).total_seconds()


	if args:
		search = re.compile('.*?'.join(re.escape(a.casefold()) for a in ' '.join(args).split()))
		def match_search(series):
			return search.search(series['title'].casefold()) is not None
	else:
		search = None


	all_series = get_series(series_config)
	to_refresh = []

	for idx, (_, imdb_id, series) in enumerate(all_series):
		if 'archived' in series:
			continue
		if search and not match_search(series):
			continue

		last_refresh = series.get(episodes_refreshed_key)
		if not last_refresh or age(last_refresh) > max_age:
			to_refresh.append(imdb_id)

	if not to_refresh:
		return

	t0 = time.time()
	print('\x1b[2mRefreshing episodes of %d series...\x1b[m' % len(to_refresh), end='', flush=True)
	promises = []

	with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
		promises = [
			executor.submit(refresh_episodes, imdb_id, series_config, out=out, progress=None)
			for imdb_id in to_refresh
		]
		concurrent.futures.wait(promises)

	print('\r\x1b[K', end='', flush=True)

	updated = 0
	downloaded = 0

	for promise in promises:
		count = promise.result()
		if count:
			updated += 1
			downloaded += count

	if updated:
		print('\x1b[2mRefreshed %d episodes across %d series [%.1fs].\x1b[m' % (downloaded, updated, time.time() - t0))
		save_series_config(series_config)


useful_episode_fields = [ 'season', 'episode', 'title', 'date', 'plot', 'runtime' ]

def transform_episode_info(episode):
	for field in list(episode.keys()):
		if field not in useful_episode_fields:
			episode.pop(field, 0)


def print_series_title(num, info, title_width=0, imdb_id=None, gray=False):
	print(format_series_title(num, info, title_width=title_width, imdb_id=imdb_id, gray=gray))


def format_series_title(num, info, title_width=0, imdb_id=None, gray=False):
	infop = {**info}

	# pad title string if width is specified
	if title_width > 0:
		infop['title'] = f'%-{title_width}s' % infop['title']

	if imdb_id is not None:
		infop['id'] = imdb_id

	if 'year' in infop:
		year = infop['year']
		if len(year) == 2:
			infop['year'] = '-'.join(str(y) for y in year)
		else:
			infop['year'] = '%d-' % year[0]

	if num is None:
		if 'added' in infop:
			infop['added'] = infop['added'].split()[0]
		#s = ' \x1b[32;1m%(added)s\x1b[22;39m ' % infop
		s = ' \a/date/%(added)s\a// ' % infop

	elif num is False:
		s = ' '

	else:
		infop['_num'] = '%5s' % f'#{num}'
		#s = '\x1b[33;1m%(_num)s ' % infop
		s = '\a/index/%(_num)s ' % infop

	s += '\a/title/%(title)s\a//  \a/year/%(year)-9s\a//' % infop
	#s += '\x1b[38;5;253m%(title)s\x1b[22;39m  \x1b[38;5;245m%(year)-9s\x1b[22;39m' % infop

	if imdb_id is not None:
		#s += f'  \x1b[2m{imdb_id}\x1b[22;39m'
		s += f'  \a/imdb/{imdb_id}\a//'

	if gray:
		# remove all escape sequences
		#s = f'\x1b[22;39;38;5;246m%s' % strip_ansi(s)
		s = f'\a//\a/dim/%s' % ctl_strip(s)
	#else:
		#print('%s' % s, end='')
	#	s += '\x1b[J'  # clear to EOL (e.g. different bg color)

	return s

# introducing "ctl" - high-level text styling using in-band control sequences
# basic syntax: \x1c|<style name>|
# and then 'style name' is mapped to underlying output-specific syntax, e.g. ANSI escape sequences for terminals.
tty_ctl = {
 	'':         lambda w, _: w('\x1b[22;23;24;25;27;28;29;39m'),  # fg: reset
	'bghi':     lambda w, _: w('\x1b[48;5;234m\x1b[J'), # bg: hilight
	'bgrst':    lambda w, _: w('\x1b[49m'),             # bg: reset
	'clr':      lambda w, _: w('\x1b[J'),
 	'b':        lambda w, _: w('\x1b[1m'),
	'dim':      lambda w, _: w('\x1b[2m'),
	'italic':   lambda w, _: w('\x1b[3m'),
	'underl':   lambda w, _: w('\x1b[4m'),
	'^':        lambda w, n: w('\x1b[%dA' % int(n)),
	'v':        lambda w, n: w('\x1b[%dB' % int(n)),
	'>':        lambda w, n: w('\x1b[%dC' % int(n)),
	'<':        lambda w, n: w('\x1b[%dD' % int(n)),
	'index':    lambda w, _: w('\x1b[33;1m'),
	'date':     lambda w, _: w('\x1b[32;1m'),
	'title':    lambda w, _: w('\x1b[38;5;253m'),
	'year':     lambda w, _: w('\x1b[38;5;245m'),
	'imdb':     lambda w, _: w('\x1b[2m'),
	'epid':     lambda w, _: w('\x1b[33;1m'),
	'eptitle':  lambda w, _: w('\x1b[34;1m'),
	'countdn':  lambda w, _: w('\x1b[32;1m'),
	'oper':     lambda w, _: w('\x1b[34;1m'),
	'duration': lambda w, _: w('\x1b[38;5;244m'),
	'total':    lambda w, _: w('\x1b[38;5;256m'),
}
def mk_ctl_tty(writer):

	_ctl_tty_buf = []
	def ctl_tty(s):
		# buffer everything, flush when LF is received

		nonlocal _ctl_tty_buf
		lf = s.find('\n')
		if lf == -1:
			_ctl_tty_buf.append(s)
			return

		sofar = ''.join(_ctl_tty_buf) + s[:lf + 1]  # up to, and including, the LF
		_ctl_tty_buf.clear()

		ctl_do(sofar, tty_ctl, writer)

		s = s[lf + 1: ]
		if s:
			ctl_tty(s)  # the bit after the LF, if any

	return ctl_tty


def format_episode_title(series_title, episode, title_width=0, gray=False, remaining=0, today=False, only_released=False):
	s = ''

	ep = {**episode}

	if series_title:
		s += f'  {series_title} '

	if title_width == 0:
		title_width = len(ep['title'])
	elif len(ep['title']) > title_width:
		title_width -= 2
		ep['title'] = ep['title'][:title_width] + '…'

	#s += f'\x1b[33;1ms{ep["season"]}e{ep["episode"]:02}\x1b[22;39m \x1b[34;1m{ep["title"]:{title_width}}\x1b[22;39m  '
	s += f'\a/epid/s{ep["season"]}e{ep["episode"]:02}\a// \a/eptitle/{ep["title"]:{title_width}}\a//  '

	future = False
	if 'date' in episode:
		dt = date.fromisoformat(ep.get('date'))
		now_date = now_datetime().date()
		diff = (dt - now_date).total_seconds()
		future = diff > 0
		if future and only_released:
			return None, False
		if today:
			today = dt == now_date
	else:
		today = False

	if future:
		#s += f'\x1b[1m{dt}\x1b[22;39m'
		s += f'\a/b/{dt}\a//'
		if diff > 24*3600:
			#s += f'\x1b[38;5;244m/{fmt_duration(diff, roughly=True)}\x1b[22;39m'
			s += f'\a/duration//{fmt_duration(diff, roughly=True)}\a//'
		if remaining:
			#s += '  \x1b[32;1m+%d\x1b[22;39m' % remaining
			s += '  \a/countdn/+%d\a//' % remaining
	elif today:
		s += '\a/countdn/TODAY\a//'
	#else:
	#	s += f'\x1b[2m{fmt_duration(episode.get("runtime", 0))}\x1b[m'

	if gray:
		s = strip_ansi(s)

	return s, not future


def fmt_duration(seconds, roughly=False):
	months = int(seconds//(3600*24*30.4366666))
	seconds -= months*3600*24*30.4366666
	weeks = int(seconds//(3600*24*7))
	seconds -= weeks*3600*24*7
	days = int(seconds//(3600*24))
	seconds -= days*3600*24
	hours = int(seconds//3600)
	seconds -= hours*3600
	minutes = int(seconds//60)
	seconds = int(seconds%60)

	units = {
		'short': { 'm': 'm', 'w': 'w', 'd': 'd', 'h': 'h', 'min': 'min', 's': 's' },
		'long': {'m': 'month', 'w': 'week', 'd': 'day', 'h': 'hour', 'min': 'minute', 's': 'second' },
	}
	unit = units['long' if roughly else 'short']
	templ = '%d %s%s' if roughly else '%d%s%s'

	parts = []

	if months > 0:
		parts.append(templ % (months, unit['m'], plural(months if roughly else 1)))
	elif weeks > 0:
		parts.append(templ % (weeks, unit['w'], plural(weeks if roughly else 1)))

	if not roughly or (not months and not weeks):
		if days > 0:
			parts.append(templ % (days, unit['d'], plural(days if roughly else 1)))

	if not roughly:
		if hours > 0:
			parts.append(templ % (hours, unit['h'], plural(hours if roughly else 1)))
		if minutes:
			parts.append(templ % (minutes, unit['min'], plural(minutes if roughly else 1)))
		if seconds:
			parts.append(templ % (seconds, unit['s'], plural(seconds if roughly else 1)))

	return ' '.join(parts)


def strip_ansi(s):
	return re.sub('\x1b\\[[0-9;]*[mJ]', '', s)


def _ep_key(episode):
	return f'{episode["season"]}:{episode["episode"]}'


def format_seen_status(series, gray=False, indent=7):
	ind = ' '*indent

	s = f'{ind}'

	seen, unseen = seen_unseen_episodes(series)
	all_seen = seen and len(seen) == len(series.get('episodes', []))

	if seen or unseen:
		#s += '\x1b[38;5;256mTotal: '
		s += '\a/total/Total: '

	if seen:
		seen_duration = sum(ep.get('runtime', 0) for ep in seen)
		#s += f'Seen: {len(seen)}  \x1b[2m{fmt_duration(seen_duration)}\x1b[m'
		s += f'Seen: {len(seen)}  \a/dim/{fmt_duration(seen_duration)}\a//'
		if all_seen:
			#s += '  \x1b[32;1mALL\x1b[m'
			s += '  \a/countdn/ALL\a//'

	if seen and unseen:
		#s += ' \x1b[34;1m-\x1b[m '
		s += ' \a/oper/-\a// '

	if unseen:
		unseen_duration = sum(ep.get('runtime', 0) for ep in unseen)
		#s += f'Unseen: {len(unseen)}  \x1b[2m{fmt_duration(unseen_duration)}\x1b[m'
		s += f'Unseen: {len(unseen)}  \a/dim/{fmt_duration(unseen_duration)}\a//'

	if seen or unseen:
		#s += '\x1b[m'
		s += '\a//'

	if gray:
		#print(f'\x1b[2m{strip_ansi(s)}\x1b[m')
		s = f'\a/dim/{strip_ctl(s)}\a//'
	#else:
		#print(s)
	s += '\n'

	title_width = 0
	if seen and unseen:
		title_width = max(len(seen[-1]['title']), len(unseen[0]['title']))

	if seen:# and not all_seen:
		# show the last *in sequence* episode marked as seen,
		# NOT the episode last *marked* as seen
		if gray:
			#print('\x1b[2m', end='')
			s += '\a/dim/'
		#print(f'{ind}Last: ', end='')
		s += f'{ind}Last: '
		s += format_episode_title('', seen[-1], gray=gray, title_width=title_width)[0] + '\n'

	if unseen:
		ep_s, future = format_episode_title('', unseen[0], gray=gray, title_width=title_width)
		if ep_s:
			if gray:
				#print('\x1b[2m', end='')
				s += '\a/dim/'
			s += f'{ind}Next: %s\n' % ep_s

	return s


def series_num_archived(series_config):
	return sum(1 if 'archived' in series else 0 for series in series_config.values())


def get_series(series_config):
	imdb_ids = sorted(series_config, key=lambda imdb_id: (series_config[imdb_id]['title'].casefold(), series_config[imdb_id].get('year', '')))

	series = []
	index = 1
	for imdb_id in imdb_ids:
		series.append( (index, imdb_id, series_config[imdb_id]) )
		index += 1

	return series


def seen_unseen_episodes(series, before=None):
	episodes = series.get('episodes', [])
	seen = series.get('seen', {})

	seen_eps = []
	unseen_eps = []

	for ep in episodes:
		if _ep_key(ep) in seen:
			seen_eps.append(ep)
		else:
			# only include episodes that are already available in 'unseen'
			dt = ep.get('date')
			if not dt:
				continue
			dt = datetime.fromisoformat(ep.get('date'))
			if before and dt > before:
				continue

			unseen_eps.append(ep)

	return seen_eps, unseen_eps


def term_width():
	try:
		return int(os.popen('stty size', 'r').read().split()[1])
	except:
		return 100


known_options = {
	None: {
	},
	'list': {
		'--all':      { 'key': 'list:all', 'alias': ['-a'], 'help': 'Show also archived series' },
		'--archived': { 'key': 'list:archived', 'alias': ['-A'], 'help': 'Show only archived series' },
		'--started':  { 'key': 'list:started', 'alias': ['-s'], 'help': 'Show only series with seen episodes.' },
		'--planned':  { 'key': 'list:planned', 'alias': ['-p'], 'help': 'Show only series without seen episodes.' },
	},
	'unseen': {
		'--future':  { 'key': 'unseen:future', 'alias': ['-f'], 'help': 'Show also future/unreleased episodes.' },
		'--started': { 'key': 'unseen:started', 'alias': ['-s'], 'help': 'Show only series with seen episodes.' },
		'--planned': { 'key': 'unseen:planned', 'alias': ['-p'], 'help': 'Show only series without seen episodes.' },
	},
}

def get_option_key(command, option):
	cmd_opts = known_options.get(command)
	if not cmd_opts:
		return None
	for opt, info in cmd_opts.items():
		if opt == option or option in info.get('alias', []):
			return info['key']
	return None


def options_help(command):
	cmd_opts = known_options.get(command)
	if not cmd_opts:
		return []

	opt_help = []
	for opt, info in cmd_opts.items():
		alias = info.get('alias')
		if alias:
			opt = (opt, *alias)
		opt_help.append( (opt, info['help']) )

	return opt_help


def print_cmd_option_help(command):
	options = options_help(command)
	if options:
		print('\x1b[1mOptions:\x1b[m')
		for opt, text in options:
			if type(opt) is tuple:
				opt = ', '.join(sorted(opt, key=lambda A: A.lstrip('-')))
			print('   %-20s %s' % (opt, text))


def print_usage(exit_code=0):
	print(f'{_b}%s{_n} / Episode Manager / (c)2021 André Jonsson' % PRG)
	print('Version %s (%s) ' % (VERSION, VERSION_DATE))
	print(f'{_b}Usage:{_n} %s [<options>] [{_c}.<command>{_n} [{_o}<args>{_n}]]' % PRG)
	print()
	print(f'Where {_c}<command>{_n} is:')
	print(f'   {_c}.add{_n}     Add series')
	print(f'   {_c}.delete{_n}  Delete series (completely remove from config)')
	print(f'   {_c}.unseen{_n}  Show unseen episodes of series')
	print(f'   {_c}.list{_n}    List series')
	print(f'   {_c}.mark{_n}    Mark episode as seen')
	print(f'   {_c}.unmark{_n}  Remove mark, as added by {_c}mark{_n}')
	print(f'   {_c}.archive{_n} Archive series (still in config, but not normally shown)')
	print(f'   {_c}.restore{_n} Restore previously archived series')
	print(f'   {_c}.refresh{_n} Refresh episode data (forcibly)')
	print()
	print('Also try: {c}<command>{n} --help')
	print()
	print('Remarks:')
	print(f'  # = Series number, as listed by e.g. the {_c}list{_n} or {_c}unseen{_n} commands.')
	print(f'  Marking/unmarking also supports ranges, e.g. {_b}%s mark 1 2 1-10{_n}' % PRG)
	print(f'  If the given command is not found, it is used as a pattern to the {_b}unseen{_n} command.')
	print(f'  Only "shortest unique" part of the commands is required, e.g. ".ar"  for "archive".')
	sys.exit(exit_code)


def print_cmd_help(command, exit_code=0):
	cmd_help[command]()
	sys.exit(exit_code)


def bad_opt(opt):
	print('Unknown option: \x1b[41;97;1m%s\x1b[m' % opt, file=sys.stderr)
	sys.exit(1)


def bad_cmd(cmd):
	print('Unknown command: \x1b[41;97;1m%s\x1b[m' % cmd, file=sys.stderr)
	sys.exit(1)


def ambiguous_cmd(name, matching):
	print('Ambiguous command: \x1b[41;97;1m%s\x1b[m  matches: %s' % (name, '\x1b[34;1m,\x1b[m '.join(sorted(matching))), file=sys.stderr)
	sys.exit(1)


def now():
	return str(now_datetime())


def now_datetime():
	return datetime.fromtimestamp(int(time.time()))


def load_series_config():
	config = {}
	if os.path.exists(series_config_file) and os.path.getsize(series_config_file) > 1:
		with open(series_config_file, 'r') as fp:
			config = json.load(fp)
	return config


compressor = 'zstd'
compression_extension = '.zst'

import shutil
if not shutil.which(compressor):
	compressor = None
	compression_extension = ''

# TODO: these should return a waitable promise (so we can do it in parallel with the serialization)
if compressor:
	from subprocess import Popen
	def mk_backup(filename, destination):
		tmp_name = mkstemp( dir=os.path.dirname(filename))[1]
		os.rename(filename, tmp_name)
		try:
			exit_code = Popen([compressor, '-18', '-q', '-f', tmp_name, '--rm', '-o', destination]).wait()
			if exit_code != 0:
				os.rename(tmp_name, destination)

		except Exception as e:
			print('\x1b[41;97;1mERROR\x1b[m Failed compressing database backup: %s' % str(e))
			os.rename(tmp_name, destination)
			exit_code = 1

		return exit_code == 0
else:
	def mk_backup(filename, destination):
		os.rename(filename, destination)

def save_series_config(config):
	if not os.path.exists(series_config_file):
		os.makedirs(os.path.dirname(series_config_file), exist_ok=True)

	def backup_name(idx):
		return '%s.%d%s' % (series_config_file, idx, compression_extension)

	# rotate backups
	for idx in range(num_config_backups - 1, 0, -1):
		if os.path.exists(backup_name(idx)):
			os.rename(backup_name(idx), backup_name(idx + 1))

	# current file becomes first backup (<name>.1)
	mk_backup(series_config_file, backup_name(1))

	# write to a temp file and then rename it afterwards
	tmp_name = mkstemp(dir=os.path.dirname(series_config_file))[1]
	try:
		with open(tmp_name, 'w') as fp:
			json.dump(config, fp, indent=2, sort_keys=True)
		os.rename(tmp_name, series_config_file)
	except Exception as e:
		print('\x1b[41;97;1mERROR\x1b[m Failed saving series database: %s' % str(e))
		os.remove(tmp_name)


def plural(n):
	if isinstance(n, (list, tuple, dict)):
		n = len(n)
	return '' if n == 1 else 's'


ctl_ptn = re.compile('\a/(\d+)?([^/]*?)/')

ctl_trace = True

def ctl_do(s, styles, writer=None):
	if ctl_trace:
		log('ctl_do: »%s«' % s)

		def tracer(writer):
			def w(s):
				log('write: »%s« (%d)' % (s, len(s)))
				writer(s)
			return w

		writer = tracer(writer)

	pos = 0
	# execute ctl-commands and forward everything else as-is
	while pos < len(s):
		m = ctl_ptn.search(s, pos)
		head = s[pos: m.start() if m else None]
		if head:
			writer(head) # fwd up to ctl code start (or end of string)

		if not m:  # no ctl code
			break

		# decode the ctl code
		arg = m.group(1)
		code = m.group(2)

		command = styles.get(code)
		if command is None:
			raise ValueError('unknown ctl code: %s' % code)

		# execute the ctl command
		command(writer, arg)

		pos = m.end()


def ctl_strip(s):
	return re.sub('\a/[^/]*?/', '', s)


def ui_main(scr):
	curses.use_default_colors()
	try:
		curses.curs_set(False)
	except:
		pass


	color_idx = 50
	def color(fg, bg=-1, bold=False, dim=False):
		nonlocal color_idx
		curses.init_pair(color_idx, fg, bg);
		pair = curses.color_pair(color_idx)
		if bold: pair |= curses.A_BOLD
		elif dim: pair |= curses.A_DIM
		color_idx += 1
		return pair

	white = color(curses.COLOR_WHITE, bold=True)
	yellow = color(curses.COLOR_YELLOW, bold=True)
	blue = color(curses.COLOR_BLUE, bold=True)
	faint = color(-1, dim=True)


	series_config = load_series_config()

	top_margin = 1
	bottom_margin = 1

	# size = None
	# last_y = None
	# last_x = None

	# style_ptn = re.compile('\x1b' + r'\[(\d+(;\d+)*)?m')
	# move_ptn = re.compile('\x1b' + r'\[(\d+)([ABCD])')

	# cy = None
	# cx = None
	# style = curses.A_NORMAL

	# def add_text(*args, **kwargs):
	# 	nonlocal cy
	# 	nonlocal cx
	# 	nonlocal style

	# 	if cy > last_y or cx > last_x:
	# 		return

	# 	text = ' '.join(str(a) for a in args)
	# 	#text = strip_ansi(text)

	# 	# TODO: interpret escape sequences or do prompt-toolkit-style "structured text" ?
	# 	m = style_ptn.search(text)
	# 	if m:
	# 		if m.start() > 0:
	# 			add_text(text[:m.start()], **kwargs, end='')
	# 		text = text[m.end(): ]

	# 		csi = m.group(1)
	# 		log('CSI text: »%s«' % text)
	# 		log('     CSI: »%s«' % csi)
	# 		if csi:
	# 			fg, bg, attr = csi2style(csi, fg, bg, style)

	# 			style = (fg or curses.A_NORMAL) | attr
	# 			if fg and style != curses.A_NORMAL:
	# 				style |= curses.A_BOLD
	# 	else:
	# 		log('CSI not found in text: »%s«' % text)

	# 	kwstr = ' '.join('%s=»%s«' % (k, v) for k, v in kwargs.items())
	# 	log('add_text(%d,%d): »%s« %s' % (cy, cx, text, kwstr))
	# 	text_parts = text.split('\n')

	# 	for part in text_parts[: -1]:
	# 		add_text(part, **kwargs, end=None)
	# 	text = text_parts[-1]

	# 	text_parts = text.split('\r')
	# 	for part in text_parts[: -1]:
	# 		add_text(part, end='')
	# 		cx = 0
	# 	text = text_parts[-1]

	# 	# execute cursor movement escape sequences
	# 	m = move_ptn.search(text)
	# 	if m:
	# 		before = text[: m.start()]
	# 		if before:
	# 			add_text(before, **kwargs, end='')
	# 		text = text[m.end(): ]
	# 		count = int(m.group(1))
	# 		direction = m.group(2)
	# 		if direction == 'A':  # up
	# 			if cy > count + top_margin:
	# 				cy -= count
	# 		elif direction == 'B':  # down
	# 			if cy < last_y - count:
	# 				cy += count
	# 		elif direction == 'D':  # left / back
	# 			if cx > count:
	# 				cx -= count
	# 		elif direction == 'C':  # right / forward
	# 			if cx < last_x - count:
	# 				cx += count

	# 	text = text[: last_x - cx]
	# 	if text:
	# 		scr.addstr(cy, cx, text, style)#curses.COLOR_WHITE)#series_title)
	# 		cx += len(text)
	# 	if kwargs.get('end') == None:
	# 		cx = 0
	# 		cy += 1

	# log('-> y: %d  x: %d' % (cy, cx))

	title_writer = CursesWriter(scr, rect=(0, 0, 0, -1))    # only first line
	menu_writer = CursesWriter(scr, rect=(-1, 0, -1, -1))   # only bottom line
	main_writer = CursesWriter(scr, rect=(top_margin, 0, -bottom_margin - 1, -1))  # the rest

	def on_resize(newsize):
		#nonlocal size
		#nonlocal last_y
		#nonlocal last_x
		title_writer.resize()
		menu_writer.resize()
		main_writer.resize()
		#size = newsize
		#last_y = size[0] - 1 - bottom_margin
		#last_x = size[1] - 1

	on_resize(scr.getmaxyx())

	def mk_ctl_curses(writer):
		def ctl_curses(s):
			ctl_do(s, curses_ctl, writer)

		return ctl_curses

	while True:
		scr.clear()

		# TODO: draw top & bottom bars/menus/titles
		title_writer.home()
		title_writer('EPM UI v0.1')

		menu_writer.home()
		menu_writer('Quit')

		#cy = top_margin
		#cx = 0

		for _ in range(10):
			log('')
		log('='*80)
		#cmd_unseen(series_config, ['who'], {'unseen:start': True}, out=mk_ctl_curses(main_writer), detail=False, show_id=False, width=last_x - 30)
		#scr.refresh()

		key = scr.getch()
		if key == -1:
			continue

		if key == ord('q'):
			break

		if key == curses.KEY_RESIZE:
			on_resize(scr.getmaxyx())

curses_styles = {
	'':      lambda writer: writer.reset_color(),
	'title': lambda writer: writer.set_color(fg=curses.COLOR_YELLOW, attr=curses.A_BOLD),
	'year':  lambda writer: writer.set_color(fg=curses.COLOR_WHITE, attr=curses.A_NORMAL),
}

def ctl_curses(writer, s):
	ctl_do(s, curses_styles, writer)

class CursesWriter:
	def __init__(self, screen, rect=None):
		self.screen = screen
		self.rect_def = rect
		self.y = 0
		self.x = 0
		self.resize()

		self.fg = -1
		self.bg = -1
		self.attr = curses.A_NORMAL


		self.home()

	def home(self):
		self.y = self.rect[0]
		self.x = self.rect[1]

	def reset_color(self):
		self.fg = -1
		self.bg = -1
		self.attr = curses.A_NORMAL

	def set_color(self, fg=None, bg=None, attr=None):
		if fg is not None:
			self.fg = fg
		if bg is not None:
			self.bg = bg
		if attr is not None:
			self.attr = attr

	def resize(self):
		self.h_w = self.screen.getmaxyx()

		# by default, the whole screen
		self.rect = [ 0, 0, self.h_w[0], self.h_w[1] ]

		if self.rect_def is not None:
			for n in range(4):
				if self.rect_def[n] >= 0:
					value = self.rect_def[n]
					if n >= 2:  # 'max' values can't be larger than screen size
						value = min(self.h_w[n - 2], value)
					self.rect[n] = value

				elif n >= 2:
					self.rect[n] = self.h_w[n - 2] - self.rect_def[n]

			log('rect: %s' % self.rect)

		# clip y & x to the rect
		self.y = min(self.rect[2] - 1, max(self.rect[0], self.y))
		self.x = min(self.rect[3] - 1, max(self.rect[1], self.x))


	def __call__(self, text):
		if self.y >= self.rect[3] or self.x >= self.rect[2]:
			return
		if len(text) + self.x >= self.rect[2]:
			text = text[: self.rect[2] - len(text)]

		self.screen.addstr(self.y, self.x, text)#, self.fg | self.attr)
		self.x += len(text)
		self.y += 1


def csi2style(csi, fg, bg, attr):
	csi = [int(c) for c in csi.split(';')]
	if not csi or csi == [0]:
		attr = curses.A_NORMAL

	#fg = 0
	#bg = 0
	#attr = curses.A_NORMAL

	while csi:
		c = csi.pop(0)
		if c == 2:
			attr |= curses.A_DIM
		elif c == 22:
			attr = curses.A_NORMAL
		if c >= 30 and c <= 37:
			fg = c - 30
		elif c >= 40 and c <= 47:
			bg = c - 40
		elif c in (38, 48) and len(csi) >= 1:
			is_fg = c == 38
			mode = csi.pop(0)
			if mode == 5 and len(csi) == 1:  # 256-color
				if is_fg:
					fg = csi.pop(0)
				else:
					bg = csi.pop(0)
			elif mode == 2 and len(csi) == 3: # true-color
				if is_fg:
					fg = csi[:3]
				else:
					fg = csi[:3]
			else:
				raise RuntimeError('bad CSI sequence: %d;%s' % (38 if is_fg else 48, mode))
		elif c == 39:
			attr = curses.A_NORMAL # should actually remove A_BOLD and A_DIM
		else:
			raise RuntimeError('bad CSI sequence: %d' % c)

	return fg, bg, style


def ui_run():
	try:
		curses.wrapper(ui_main)
	except KeyboardInterrupt:
		pass

if __name__ == '__main__':
	main(sys.argv[1: ])
