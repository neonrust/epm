#! /usr/bin/env python3
# -*- mode: python -*-

import sys
try:
	import orjson
except:
	import json
	orjson = None

import os.path
import re
import time
from datetime import datetime, date, timedelta
import concurrent.futures
from tempfile import mkstemp

import tmdb

VERSION = '0.6'
VERSION_DATE = '2022-07-14'

PRG = os.path.basename(sys.argv[0])

default_max_refresh_age = 2  # days
refreshed_key = 'refreshed-at'

series_config_file = os.path.expandvars(f'$HOME/.config/{PRG}/series')
num_config_backups = 10


def main():
	command = None
	command_args = []
	options = {
		'max-age': default_max_refresh_age,
	}

	def resolve_cmd(name):
		matching = []

		for cmd in known_commands:
			for alias in cmd:
				if name == alias or alias.startswith(name.lower()):
					matching.append(cmd[0]) # the first alias is the "long version", guaranteed to be unique
					break

		if len(matching) == 1:
			return matching[0]
		if len(matching) > 1:
			ambiguous_cmd(name, matching)

		return None


	args = sys.argv[1: ]
	while args:
		arg = args.pop(0)

		#print('check arg: "%s"' % arg)

		if arg.startswith('-'):
			if not command:
				if arg in '--help':
					print_usage()

				command = default_command
				#print('  -> cmd: %s (default)' % command)

			#print('  opt:', arg, '(cmd: %s)' % command)
			if not eat_option(command, arg, args, options):
				bad_opt(command, arg)
			else:
				continue

		if not command and not arg.startswith('.'):
			#print('  try cmd: "%s"' % arg)
			command = resolve_cmd(arg)
			if command:
				#print('  -> cmd: %s [%s]' % (command, ' '.join(command_args)))
				continue

		if not command:
			if arg.startswith('.'):
				arg = arg[1: ]

			command = default_command
			#print('  -> cmd: %s (default)' % command)

		if command:
			#print('  cmd arg:', arg)
			command_args.append(arg)

	if not command:
		command = default_command

	if command == 'help':
		print_usage()

	series_config = load_series_config()

	try:
		handler = cmd_handlers[command]
	except KeyError:
		print('%s: Unknown command: %s' % (PRG, command))
		sys.exit(1)

	err = handler(series_config, command_args, options, width=term_width())
	if err is not None:
		print(f'{_c}[{_0}{_b}{PRG} {command}{_c}]{_0} {err}')
		sys.exit(1)


def eat_option(command, option, args, options) -> bool:
	if option in ('-h', '--help'):
		if command:
			print_cmd_help(command)
		else:
			print_usage()

	command = command or default_command
	opt_def = option_def(command, option)

	if not opt_def:
		bad_opt(command, option)

	arg_type = opt_def.get('arg')
	if arg_type is not None:
		arg = args.pop(0)
		if arg_type is int:
			try:
				arg = int(arg)
			except ValueError:
				bad_opt_arg(command, option, arg, arg_type)

		elif arg_type is datetime:
			try:
				arg = datetime.fromisoformat(arg)
			except ValueError:
				bad_opt_arg(command, option, arg, arg_type)

		opt_arg = arg

	else:
		opt_arg = True

	options[opt_def['key']] = opt_arg

	return True


def cmd_unseen(series_config, args, opts, width=None) -> str|None:
	refresh_all(series_config)

	series_list = get_series(series_config)
	if not series_list:
		return no_series(series_config)

	#                 idx   year2+pad         dash pad eps                  margin
	max_width = width - 5 - 3 - len('1968')*2 - 1 - 2 - 3 - len('episodes')

	# TODO: print header/columns

	upto_future = 'unseen:future' in opts
	only_started = 'unseen:started' in opts
	only_planned = 'unseen:planned' in opts
	all_unseen = 'unseen:all_episodes' in  opts

	if only_started and only_planned:
		return 'Can\'t specify -s and -p at the same time'

	find_id, match = find_id_or_match(args)

	series_unseen = []
	for index, series_id, series in series_list:
		if find_id is not None:
			if find_id != index:
				continue
		else:
			if match and not match(series):
				continue

		_, unseen = seen_unseen_episodes(series)
		if unseen:
			series_unseen.append((index, series_id, series, unseen))
			if max_width is None:
				max_width = max(max_width or 0, len(series['title']))

	if not series_unseen:
		if match:
			return 'Nothing matched: %s (or everything already seen)' % match.pattern
		return 'Everything has been seen, better add some series!'


	print(f'{_f}Listing {_0}', end='')
	if only_started:
		print('started ', end='')
	elif only_planned:
		print('planned ', end='')
	print(f'{_f}series with unseen episodes', end='')
	if match:
		print(', matching "%s"' % match.pattern, end='')
	print(f'.{_0}')

	# TODO: optionally sort series by "earliest" episode in summary mode

	num_shown = 0
	total_duration = 0
	indent = 14
	next_header = f'%{indent}s' % 'Next: '

	# ep_max_width = width - len(next_header) - 1
	#if not ep_max_width:
	#	ep_max_width = max(len(unseen[0]['title']) if unseen else 0 for _, _, _, unseen in series_unseen for ep in unseen)
	#	ep_max_width = min(ep_max_width, 25)

	for index, series_id, series, unseen in series_unseen:

		any_episodes_seen = bool(get_meta(series, 'seen', {}))
		if only_started and not any_episodes_seen:
			continue
		if only_planned and any_episodes_seen:
			continue

		# alternate styling odd/even rows
		hilite = (num_shown % 2) == 0

		series_printed = False
		def print_series():
			if hilite:
				print('\x1b[48;5;234m', end='')

			print_series_title(index, series, title_width=max_width, tail=tail)
			nonlocal series_printed
			series_printed = True

		tail = None
		if not all_unseen:
			tail = f' {_f}%3d unseen{_0fg}' % len(unseen)

		if all_unseen:
			# print all unseen episodes
			current_season = 0
			indent = 6
			for idx, ep in enumerate(unseen):

				if not is_released(ep):
					break

				# remaining = len(unseen) - idx - 1  # what's this for?
				s = format_episode_title(f'\x1b[{indent}C', ep, width=width - indent, today=True)

				if not series_printed:
					print_series()

				season = ep['season']
				if season != current_season:
					print(f'%{indent}s\r' % ('s%d' % season), end='')
					current_season = season

				print(s)
				total_duration += ep.get('runtime') or 0

			if current_season != 0:  # meaning we printed at least one episode (and the series)
				num_shown += 1

		else:
			# print first episode
			if not is_released(unseen[0]):
				break

			s = format_episode_title(None, unseen[0], width=width - indent, today=True)

			if not series_printed:
				print_series()

			print(f'{next_header}{s}')

			num_shown += 1
			total_duration += unseen[0].get('runtime') or 0

		if hilite:
			print(_0, end='')

	# this is wildly incorrect!
	#print(f'\x1b[48;5;235m\x1b[J\rTotal unseen: \x1b[1m{total}{_0fg} episodes  \x1b[2m{fmt_duration(total_duration)}{_0fg}')

def _unseen_help() -> None:
	print(f'{_b}Show unseen episodes of series{_0}')
	print_cmd_usage('unseen', '<options> <search...>')
	print(f'    {_o}# / <IMDb ID>       {_0} Show only specific')
	print(f'    {_o}[<pattern>]         {_0} Show only matching')

cmd_unseen.help = _unseen_help


def cmd_list(series_config, args, opts, width=None) -> str|None:
	refresh_all(series_config)

	series_list = get_series(series_config)
	if not series_list:
		return no_series(series_config)

	# TODO: someone should explain what these numbers are... b/c I don't know
	max_width = width - 5 - 3 - len('1968')*2 - 1 - 2 - 3 - len('episodes')
	#max_width = max(map(lambda item: len(item[-1]['title']) if not get_meta(item[-1], 'archived') else 0, series_list))

	# TODO: print header/columns

	list_all = 'list:all' in opts
	only_archived = 'list:archived' in opts
	only_started = 'list:started' in opts
	only_planned = 'list:planned' in opts
	all_unseen = 'list:all_episodes' in  opts

	find_id, match = find_id_or_match(args)

	print(f'{_f}Listing ', end='')
	if only_started:
		print('started ', end='')
	elif only_planned:
		print('planned ', end='')
	elif only_archived:
		print('archived ', end='')
	print('series', end='')
	if match:
		print(', matching "%s"' % match.pattern, end='')
	print(f'.{_0}')

	num_shown = 0
	num_archived = 0

	for index, series_id, series in series_list:
		archived = get_meta(series, 'archived')

		if find_id is not None:
			if index != find_id:
				continue
		else:
			if archived:
				num_archived += 1
			if archived and not (list_all or only_archived):
				continue
			if not archived and only_archived:
				continue
			has_episodes_seen = len(get_meta(series, 'seen', {})) > 0
			if only_started and not has_episodes_seen:
				continue
			if only_planned and has_episodes_seen:
				continue
			if match and not match(series):
				continue

		# alternate styling odd/even rows
		hilite = (num_shown % 2) == 0

		num_shown += 1

		if hilite:
			print('\x1b[48;5;234m', end='')

		print_series_title(index, series, imdb_id=series.get('imdb_id'), title_width=max_width, gray=archived and not only_archived)

		if archived and not only_archived:
			print(f'{_f}       Archived{_0fg}')

		print_seen_status(series, gray=archived and not only_archived, print_next=not all_unseen, width=width)

		if all_unseen:
			_, unseen = seen_unseen_episodes(series)
			indent = 6
			current_season = 0
			for idx, ep in enumerate(unseen):

				if not is_released(ep):
					break

				# remaining = len(unseen) - idx - 1  # what's this for?
				s = format_episode_title(f'\x1b[{indent}C', ep, width=width - indent, today=True)

				season = ep['season']
				if season != current_season:
					print(f'%{indent}s\r' % ('s%d' % season), end='')
					current_season = season
				print(s)

		if hilite:
			print(_0, end='')

	if num_shown == 0:
		if match:
			return 'Nothing matched: %s' % match.pattern

	print(f'{_0}{_K}', end='')
	print(f'{_b}\x1b[48;2;20;50;20m%d series {_fi}Total: %d   Archived: %d{_K}{_0}' % (num_shown, len(series_list), num_archived))


def _list_help() -> None:
	print(f'{_b}List series{_0}')
	print_cmd_usage('list', '<options> [<title search>...]')
	print(f'    {_o}[<title search>]     {_0} Show only matching series')

cmd_list.help = _list_help


year_ptn = re.compile(r'^(\d{4})|\((\d{4})\)$')  # 1968 or (1968)

def cmd_add(series_config, args, opts, width=None) -> str|None:
	if not args:
		return 'required argument missing: <title> / <Series ID>'

	args = list(a for a in ' '.join(args).split())
	year = None
	if len(args) >= 2:
		m = year_ptn.match(args[-1])
		if m:
			args.pop()
			year = int(m.group(1) or m.group(2))

	search = ' '.join(args)

	print(f'{_f}- Searching "%s"' % search, end='')
	if year:
		print(' (%d)' % year, end='')
	print(f' ...{_0}')

	hits = tmdb.search(search, year=year)
	print(f'\r{_K}', end='')
	if not hits:
		return 'Nothing found. Try generalizing your search.'

	if len(hits) > 1:
		# exclude ones we already have in our config
		already = list(filter(lambda H: H['id'] in series_config, hits))
		if already:
			print(f'{_f}Already added: %d{_0}' % len(already))
			for hit in already:
				if has_meta(series_config[hit['id']], 'archived'):
					arch_tail = f'  \x1b[33m(archived){_0}'
				else:
					arch_tail = None

				imdb_id = series_config[hit['id']].get('imdb_id')
				print_series_title(None, series_config[hit['id']], imdb_id=imdb_id, gray=True, tail=arch_tail)

		max_width = width - 5 - 3 - len('1968')*2 - 1 - 2 - 3 - len('episodes')
		#max_width = max(len(series['title']) for series in hits)

		hits = list(filter(lambda H: H['id'] not in series_config, hits))
		print(f'{_g}Found {_0}{_b}%d{_0} {_g}series:{_0}' % len(hits))

		print(f'{_f}Enriching search hits...{_0}', end='', flush=True)
		hit_details = tmdb.details([ hit['id'] for hit in hits ])
		print(f'\r{_K}', end='')

		for idx, hit in enumerate(hits):
			hit.update(hit_details[idx])
			imdb_id = hit.get('imdb_id')
			print_series_title(idx + 1, hit, imdb_id=imdb_id, title_width=max_width)

		last_num = len(hits)
		while True:
			try:
				selected = input(f'\x1b[44;97;1mSelect series (1 - %d) to add -->{_0} ' % last_num).lstrip('#')
			except (KeyboardInterrupt, EOFError):
				print()
				selected = None

			if not selected:
				return 'Nothing selected, cancelled'

			try:
				selected = int(selected)
				if selected <= 0 or selected > last_num:
					raise ValueError()
			except ValueError:
				print(f'{_E}*** Bad selection, try again ***{_0}', file=sys.stderr)
				continue

			selected -= 1
			break
	else:
		selected = 0

	hit = hits[selected]
	series_id = hit['id']

	hit[meta_key] = {}
	set_meta(hit, 'seen', {})
	set_meta(hit, 'added', now())

	hit.pop('id', None)

	series_config[series_id] = hit


	refresh_series(series_id, series_config)

	# TODO: offer to mark seasons as seen?

	save_series_config(series_config)

	print(f'{_b}Series added:{_0}  {_f}(series renumbered){_0}')

	# need to loop to figure out its list index
	imdb_id = series_config[series_id].get('imdb_id')
	index = find_list_index(series_config, series_id)
	print_series_title(index, hit, imdb_id=imdb_id)


def _add_help() -> None:
	print(f'{_b}Search for a series and (optionally) add it.{_0}')
	print_cmd_usage('add', '<title search> [<year>]')

cmd_add.help = _add_help


def cmd_delete(series_config, args, opts, width=None) -> str|None:
	if not args:
		return 'Required argument missing: # / <IMDb ID>'

	index, series_id, series, err = find_series(series_config, args.pop(0))
	if err is not None:
		return err

	del series_config[series_id]

	print(f'{_b}Deleting series:{_0}')
	print_series_title(None, series, imdb_id=series.get('imdb_id'))

	answer = input(f'\x1b[41;37;1mAre you sure? (can not be undone){_0} [yes/No] ')
	if answer.lower() not in ('y', 'yes'):
		return 'Delete cancelled'

	save_series_config(series_config)

	print(f'{_b}Series deleted:{_b} {_f}(series renumbered){_0}')
	print_series_title(index, series, imdb_id=series.get('imdb_id'))

def _delete_help() -> None:
	print(f'{_b}Complete remove a series - permanently!{_0}')
	print_cmd_usage('delete', '# / <IMDb ID>')
	print(f'    {_o}# / <IMDb ID>{_0}')

cmd_delete.help = _delete_help


def cmd_mark(series_config, args, opts, marking=True, width=None) -> str|None:
	refresh_all(series_config)

	if not args:
		return 'Required argument missing: # / <IMDb ID>'

	find_id = args.pop(0)

	index, series_id, series, err = find_series(series_config, find_id)
	if err is not None:
		return err

	season = None
	episode = None

	ep_ptn = re.compile(r'^\s*(s\d+(-\d+)?)(e\d+(-\d+)?)\s*$')

	# supported syntaxes:
	#   nothing:                                (all seasons, all episodes)
	#   single numbers:              1 2        (season 1, episode 2)
	#   ranges:                      1-2 1-5    (season 1-2, episode 1-5)
	#   season descriptor:           s1         (season 1, all episodes)
	#   "descriptor":                s1e2       (season 1, episode 2)
	#   "descriptor" spaces:         s1 e2      (season 1, episode 2)
	#   "descriptor" ranges:         s1-3e1-4   (season 1-3, episode 1-4)
	#   "descriptor" spaced ranges:  s1-3 e1-4  (season 1-3, episode 1-4)

	if args:
		arg = args.pop(0)

		m = ep_ptn.search(arg)
		if m:
			args = [ m.group(1) ]
			if m.group(3):
				args.append(m.group(3))

		else:
			args.insert(0, arg)

	if args:
		season = args.pop(0)

		try:
			rng = [int(n) for n in season.lower().lstrip('s').split('-')]
			if len(rng) == 2:
				season = range(min(rng), max(rng) + 1)
			else:
				season = (int(rng[0]), )
		except ValueError as ve:
			return f'Bad season number/range: {season}'

	if args:
		episode = args.pop(0)

		try:
			rng = [int(n) for n in episode.lower().lstrip('e').split('-')]
			if len(rng) == 2:
				episode = range(min(rng), max(rng) + 1)
			else:
				episode = (int(rng[0]), )
		except:
			return f'Bad episode number/range: {episode}'

	seen = get_meta(series, 'seen', {})

	episodes = []
	episodes_runtime = 0

	for ep in series.get('episodes', []):
		if (season is None or ep['season'] in season) and (episode is None or ep['episode'] in episode):
			key = _ep_key(ep)

			if marking and key not in seen:
				seen[key] = now()
				episodes.append(ep)
				episodes_runtime += ep.get('runtime') or 0

			elif not marking and key in seen:
				del seen[key]
				episodes.append(ep)

	if episodes:
		if marking:
			print('Marked ', end='')
		else:
			print('Unmarked ', end='')

		print(f'{_c}{len(episodes)}{_0}', end='')
		print(f' episode{plural(episodes)} as seen:  {_0}{_f}{fmt_duration(episodes_runtime)}{_0}')
		max_width = width #max(len(ep['title']) for ep in episodes)

		for ep in episodes:
			print(format_episode_title(series['title'], ep, width=max_width))

		save_series_config(series_config)

	else:
		print(f'{_c}No episodes %smarked{_0}' % '' if marking else 'un')


def _mark_help() -> None:
	print(f'{_b}Mark a series, season or specific episode as seen.{_0}')
	print_cmd_usage('mark', '# / <IMDb ID> [<season / episode specifier>]')
	print(f'    {_o}# / <IMDb ID> <season> <episode> {_0} Episodes')
	print(f'    {_o}# / <IMDb ID> <season>           {_0} Seasons')
	print(f'    {_o}# / <IMDb ID>                    {_0} Whole series')
	print('Also support ranges:')
	print('  > %s .mark 42 1 1-5' % PRG)
	print('And episode specifiers (with ranges):')
	print('  > %s unmark 42 s1e1-5' % PRG)

cmd_mark.help = _mark_help


def cmd_unmark(*args, **kwargs):
	return cmd_mark(*args, **kwargs, marking=False)

def _unmark_help() -> None:
	print(f'{_b}Unmark a series/season/episode - reverse of mark command.{_0}')
	print_cmd_usage('unmark', '# / <IMDb ID> [<season / episode specifier>]')
	print(f'    {_o}# / <IMDb ID> <season> <episode> {_0} Episodes')
	print(f'    {_o}# / <IMDb ID> <season>           {_0} Seasons')
	print(f'    {_o}# / <IMDb ID>                    {_0} Whole series')
	print('Also support ranges:')
	print('  > %s unmark 42 1 1-5' % PRG)
	print('And episode specifiers (with ranges):')
	print('  > %s unmark 42 s1e1-5' % PRG)

cmd_unmark.help = _unmark_help

def cmd_archive(series_config, args, opts, archiving=True, width=None) -> str|None:
	if not args:
		return 'Required argument missing: # / <IMDb ID>'

	find_id = args.pop(0)

	index, series_id, series, err = find_series(series_config, find_id)
	if err is not None:
		return err

	currently_archived = has_meta(series, 'archived')

	# TODO: check if all episodes are seen or not?

	if archiving == currently_archived:
		# TODO: better presentation of title
		if archiving:
			return 'Already archived: %s' % series['title']
		else:
			return 'Not archived: %s' % series['title']

	if archiving:
		print(f'{_b}Series archived:{_0}')
		set_meta(series, 'archived', True)
	else:
		print(f'{_b}Series restored:{_0}')
		del_meta(series, 'archived')

	print_series_title(index, series, imdb_id=series.get('imdb_id'))

	save_series_config(series_config)


def _archive_help() -> None:
	print(f'{_b}Archving series - hides from normal list command.{_0}')
	print_cmd_usage('archive', '# / <IMDb ID>')
	print(f'    {_o}# / <IMDb ID>{_0}')

cmd_archive.help = _archive_help


def cmd_restore(*args, **kwargs) -> None:
	return cmd_archive(*args, **kwargs, archiving=False)

def _restore_help() -> None:
	print(f'{_b}Restore series - reverse of archive command.{_0}')
	print_cmd_usage('restore', '# / <IMDb ID>')
	print(f'    {_o}# / <IMDb ID>{_0}')

cmd_restore.help = _restore_help


def cmd_refresh(series_config, args, opts, width=None) -> None:
	return refresh_all(series_config, args, opts)

def _refresh_help() -> None:
	print(f'{_b}Refresh episode data of all non-archived series.{_0}')
	print_cmd_usage('refresh', '# / <IMDb ID> {_o}|{_n} <pattern>')
	print(f'    {_o}[# / <IMDb ID>]     {_0} Only the specified series')
	print(f'    {_o}[<pattern>]         {_0} Only matching series')

cmd_refresh.help = _refresh_help



def get_meta(series:dict, key: str, def_value=None):
	return series.get(meta_key).get(key, def_value)

def has_meta(series:dict, key: str):
	return series.get(meta_key).get(key) is not None

def set_meta(series:dict, key: str, value) -> None:
	series[meta_key][key] = value

def del_meta(series:dict, key: str) -> None:
	series[meta_key].pop(key, None)

# known commands with aliases (apart from resolving shortest-unique)
known_commands = (
	('add', 'a'),
	('delete', ),
	('list', 'ls'),
	('unseen', 'u', 'us'),
	('mark', 'm'),
	('unmark', 'M', 'um'),
	('archive', 'A'),
	('restore', 'R'),
	('refresh', 'r'),
	('help', ),
)

default_command = 'unseen'
cmd_handlers = {
		'add':     cmd_add,
		'delete':  cmd_delete,
		'list':    cmd_list,
		'unseen':  cmd_unseen,
		'mark':    cmd_mark,
		'unmark':  cmd_unmark,
		'archive': cmd_archive,
		'restore': cmd_restore,
		'refresh': cmd_refresh,
}

known_options = {
	None: {
	},
	'list': [
		{ 'option': ('-a', '--all'),      'key': 'list:all',          'help': 'Show also archived series' },
		{ 'option': ('-A', '--archived'), 'key': 'list:archived',     'help': 'Show only archived series' },
		{ 'option': ('-s', '--started'),  'key': 'list:started',      'help': 'Show only series with seen episodes.' },
		{ 'option': ('-p', '--planned'),  'key': 'list:planned',      'help': 'Show only series without seen episodes.' },
		{ 'option': ('-e', '--episodes'), 'key': 'list:all_episodes', 'help': 'Show all unseen episodes (not only first).' },
	],
	'unseen': [
		{ 'option': ('-f', '--future'),   'key': 'unseen:future',       'help': 'Show also future/unreleased episodes.' },
		{ 'option': ('-s', '--started'),  'key': 'unseen:started',      'help': 'Show only series with seen episodes.' },
		{ 'option': ('-p', '--planned'),  'key': 'unseen:planned',      'help': 'Show only series without seen episodes.' },
		{ 'option': ('-e', '--episodes'), 'key': 'unseen:all_episodes', 'help': 'Show all unseen episodes (not only first).' },
	],
	'refresh': [
		{ 'option': ('-f', '--force'), 'key': 'refresh:force',  'help': 'Refresh whether needed or not.' },
		{ 'option': ('--max-age',),    'key': 'max-age',  'arg': int, 'help': 'Refresh older than N days (default: %s)' % default_max_refresh_age },
	],
}


def find_series(series_config:dict, find_id:str) -> tuple[int|None, str|None, dict|None, str|None]:
	nothing_found = None, None, None, f'Series not found: {find_id}'

	# if it starts with 'tt' (and rest numerical), search by IMDb ID
	# else search listing index (as dictated by get_series())

	if not find_id:
		return nothing_found

	try:
		find_index = int(find_id)
	except:
		find_index = None
		if find_id[0] == 'tt':
			find_id = find_id[1:]
		else:
			return nothing_found

	for index, series_id, series in get_series(series_config):
		if find_index is not None and find_index == index:
			return index, series_id, series, None
		elif series.get('imdb_id') == find_id:
			return index, series_id, series, None

	return nothing_found


def find_list_index(series_config, series_id):
	for index, sid, _ in get_series(series_config):
		if sid == series_id:
			return index
	return None


def is_released(target, fallback=True):
	release_date = target.get('release_date')
	if release_date is None:
		return fallback

	return date.fromisoformat(release_date) <= today_date



def find_id_or_match(args):

	# TODO: return a function: (list_index, series) -> bool

	if not args:
		return None, None

	try:
		find_id = int(args[0])
		return find_id, None
	except ValueError:
		ptn = re.compile('.*?'.join(re.escape(a.casefold()) for a in ' '.join(args).split()))
		def match(series):
			return ptn.search(series['title'].casefold()) is not None
		match.pattern = ptn.pattern
		return None, match


def no_series(series_config:dict) -> str:
	num_archived = series_num_archived(series_config)
	suffix = f'Use: {_b}%s add <title search...> [<year>]{_0}' % PRG
	if num_archived:
		return 'No active series [but %d archived]. %s' % (num_archived, suffix)
	else:
		return 'No series added. %s' % suffix


meta_key = 'epm:meta'
legacy_meta_keys = ('added', refreshed_key, 'seen', 'archived')

def refresh_series(series_id:str, series_config:dict, progress:bool=False) -> int:
	if progress:
		print(f'{_f}(%d / %d) Refreshing %s...{_0}' % (progress[0], progress[1], series_id), end='', flush=True)
	elif progress is False:
		print(f'{_f}Refreshing %s...{_0}' % series_id, end='', flush=True)

	details, episodes = tmdb.episodes(series_id, with_details=True)
	if progress is not None:
		print(f'\r{_K}', end='', flush=True)

	for ep in episodes:
		transform_episode_info(ep)

	#updated = len(episodes) > len(series_config[series_id].get('episodes', []))

	meta_data = series_config[series_id].get(meta_key, {})

	series_config[series_id] = details
	series_config[series_id][meta_key] = meta_data
	set_meta(series_config[series_id], refreshed_key, now())
	series_config[series_id]['episodes'] = episodes

	return len(episodes)


def refresh_all(series_config:dict, args:list=None, opts:dict=None) -> None:

	t0 = time.time()

	opts = opts or {}
	max_age = opts.get('max-age', default_max_refresh_age)
	if max_age <= 0:
		max_age = default_max_refresh_age
	max_age_s = max_age*3600*24
	forced = bool(opts.get('refresh:force'))

	find_id, match = find_id_or_match(args)

	series_list = get_series(series_config)

	to_refresh = []

	now_dt = now_datetime()
	def age(dt):
		return (now_dt - datetime.fromisoformat(dt)).total_seconds()

	earliest_refresh = None

	for index, series_id, series in series_list:
		if has_meta(series, 'archived'):
			continue

		if find_id is not None:
			if find_id != index:
				continue
		else:
			if match and not match(series):
				continue

		last_refresh = get_meta(series, refreshed_key)
		#print('%s last refresh: %s' % (series_id, last_refresh))
		if forced or (not last_refresh or age(last_refresh) > max_age_s):
			to_refresh.append(series_id)
			if not earliest_refresh or last_refresh < earliest_refresh:
				earliest_refresh = last_refresh

	if not to_refresh:
		if match:
			return 'Nothing matched: %s' % match.pattern
		return 'Nothing to update (max age: %d days)' % max_age

	if not forced:
		print(f'\r{_f}Checking for updates (%d series)...{_0}{_K}' % len(to_refresh), end='', flush=True)
		changes = tmdb.changes(to_refresh, datetime.fromisoformat(earliest_refresh), ignore=ignore_changes)
		for series_id, changes in zip(to_refresh, changes):
			if not changes:
				to_refresh.remove(series_id)

	if not to_refresh:
		return 'No updates'

	print('\r', end='')
	if forced:
		print(f'\x1b[33m(forced){_0} ', end='')
	print(f'{_f}Refreshing %d series...{_0}{_K}' % len(to_refresh), end='', flush=True)

	with concurrent.futures.ThreadPoolExecutor(max_workers=16, thread_name_prefix='%s-request' % PRG) as executor:
		promises = [
			executor.submit(refresh_series, series_id, series_config, progress=None)
			for series_id in to_refresh
		]
		concurrent.futures.wait(promises)

	print(f'\r{_K}', end='', flush=True)

	updated = 0
	downloaded = 0

	for promise in promises:
		count = promise.result()
		if count:
			updated += 1
			downloaded += count

	if updated:
		print(f'{_f}Refreshed %d episodes across %d series [%.1fs].{_0}' % (downloaded, updated, time.time() - t0))
		save_series_config(series_config)


useful_episode_fields = [ 'season', 'episode', 'title', 'date', 'overview', 'runtime' ]

def transform_episode_info(episode:dict):
	for field in list(episode.keys()):
		if field not in useful_episode_fields:
			episode.pop(field, 0)

def print_series_title(num:int, info:dict, title_width:int=0, imdb_id:str=None, gray:bool=False, tail:str|None=None, archived:bool=True):

	# this function should never tough the BG color

	infop = {**info}

	# pad title string if width is specified
	if title_width > 0:
		infop['title'] = f'%-{title_width}s' % infop['title']

	if imdb_id is not None:
		infop['imdb_id'] = imdb_id

	if 'year' in infop:
		year = infop['year']
		if len(year) == 2:
			infop['year'] = '-'.join(str(y) for y in year)
		else:
			infop['year'] = '%d-' % year[0]
	else:
		infop['year'] = '  ? '

	if num is not None:
		infop['_num'] = '%5s' % f'{num}'

		s = f'\x1b[3;38;2;200;160;100m%(_num)s{_0fg} \x1b[38;5;253m%(title)s{_0fg}  \x1b[38;5;245m%(year)-9s{_0fg}' % infop

	elif has_meta(infop, 'added'):
		infop['added'] = get_meta(infop, 'added').split()[0]
		s = f' {_g}%(added)s{_0fg}  \x1b[38;5;253m%(title)s{_0fg}  \x1b[38;5;245m%(year)-9s{_0fg}' % infop

	if imdb_id:
		s += f'  {_f}%s{_0fg}' % imdb_id

	if tail:
		s += tail

	if gray:
		# remove all escape sequences and print in faint-ish gray
		print(f'{_0fg}\x1b[38;5;246m%s' % strip_ansi(s), end='')
	else:
		print(s, end='')

	print(_K)



def format_episode_title(prefix_str:str, episode:dict, width:int=0, gray:bool=False, today:bool=False) -> tuple[str, bool]:

	# this function should never touch the BG color

	# print('width 0:', width)

	ep = {**episode}

	season_ep = f'\x1b[33ms{_b}{ep["season"]}\x1b[22me{_b}{ep["episode"]:02}{_0fg}'
	season_ep_w = len('s10e100 ')
	width -= season_ep_w

	# print('width 1:', width)

	# Depending on episode release date:
	#   in the future    -> show how long until release (or nothing if only_released=True)
	#   in th past       -> show the date
	#   same date as now -> show 'TODAY'


	future = False
	if 'date' in ep:
		# ep['date'] = '2026-11-11'
		# ep['date'] = (now_datetime().date() + timedelta(days=-2)).isoformat()

		dt = date.fromisoformat(ep.get('date'))
		now_date = now_datetime().date()
		diff = (dt - now_date).total_seconds()
		future = diff > 0

		if today:
			today = dt == now_date
			if today:
				future = False
	else:
		today = False

	# print('date:', ep['date'])
	# print('future:', future)
	# print('today:', today)

	ep_time_w = 1 + len('999 months')  # the longest variant of date or duration
	ep_time = None
	time_style = ''
	if future:
		ep_time = f' {dt}'
		time_style = _b

		if diff > 24*3600:  # longer than 24 hours
			ep_time = fmt_duration(diff, roughly=True)
			time_style = '\x1b[38;5;244m'

	elif today:
		ep_time = f' TODAY'
		time_style = _g

	elif 'date'in ep:
		ep_time = f' {ep["date"]}'
		time_style = ''

	if not ep_time:
		ep_time_w = 0

	if ep_time:
		width -= 1 + ep_time_w
		ep_time = f' {time_style}{ep_time:>{ep_time_w}}{_0fg}'

	# print('width 2:', width)

	runtime = ''
	if ep.get('runtime'):
		runtime = ' %dmin' % ep.get('runtime')  # could use fmt_duration() but we only want minutes here
		width -= len(runtime)

	width -= 2

	# print('width 3:', width)

	s = ''
	if prefix_str:
		s += f' {prefix_str} '
		width -= 1 + len(prefix_str) - 1

	# print('width 4:', width)

	# not enough space: truncate & ellipt
	if len(ep['title']) > width:
		width -= 2
		ep['title'] = ep['title'][:width] + '…'

	# print('width 5:', width)

	s += f'{season_ep:>{season_ep_w}} {_o}{ep["title"]:{width}}{_f}{runtime}{_0fg}{ep_time}'

	if gray:
		s = strip_ansi(s)

	return s


def fmt_duration(seconds: int|float, roughly: bool=False):
	months = int(seconds//(3600*24*30.4366666))
	seconds -= months*3600*24*30.4366666
	weeks = int(seconds//(3600*24*7))
	seconds -= weeks*3600*24*7
	days = int(seconds//(3600*24))
	seconds -= days*3600*24
	hours = int(seconds//3600)
	seconds -= hours*3600
	minutes = int(seconds//60)
	seconds = 0 #int(seconds%60)

	units = {
		'short': { 'm': 'm', 'w': 'w', 'd': 'd', 'h': 'h', 'min': 'min', 's': 's' },
		'long': {'m': 'month', 'w': 'week', 'd': 'day', 'h': 'hour', 'min': 'minute', 's': 'second' },
	}
	unit = units['long' if roughly else 'short']
	templ = '%d %s%s' if roughly else '%d%s%s'

	parts = []

	if months > 0:
		parts.append(templ % (months, unit['m'], plural(months if roughly else 1)))
	elif weeks > 0:
		parts.append(templ % (weeks, unit['w'], plural(weeks if roughly else 1)))

	if not roughly or (not months and not weeks):
		if days > 0:
			parts.append(templ % (days, unit['d'], plural(days if roughly else 1)))

	if not roughly:
		if hours > 0:
			parts.append(templ % (hours, unit['h'], plural(hours if roughly else 1)))
		if minutes or (hours > 0 or seconds > 0):
			parts.append(templ % (minutes, unit['min'], plural(minutes if roughly else 1)))
		if seconds:
			parts.append(templ % (seconds, unit['s'], plural(seconds if roughly else 1)))

	return ' '.join(parts)


def strip_ansi(s: str):
	return re.sub('\x1b\\[[0-9;]*[mJ]', '', s)


def _ep_key(episode:dict):
	return f'{episode["season"]}:{episode["episode"]}'


def print_seen_status(series:dict, gray: bool=False, print_next=True, width:int=0):
	ind = '       '

	print(f'{ind}', end='')
	width -= len(ind)

	seen, unseen = seen_unseen_episodes(series)
	all_seen = seen and len(seen) == len(series.get('episodes', []))

	s = ''

	if seen or unseen:
		s += '\x1b[38;5;256mSummary: '

	if seen:
		seen_duration = sum((ep.get('runtime') or 0) for ep in seen)
		s += f'Seen: {len(seen)}  {_f}{fmt_duration(seen_duration)}{_0fg}'
		if all_seen:
			s += f'  {_g}ALL{_0fg}'

	if seen and unseen:
		s += f' {_o}-{_0fg} '

	if unseen:
		unseen_duration = sum((ep.get('runtime') or 0) for ep in unseen)
		s += f'Unseen: {len(unseen)}  {_f}{fmt_duration(unseen_duration)}{_0fg}'

	if seen or unseen:
		s += _0fg

	if gray:
		print(f'{_f}{strip_ansi(s)}{_0fg}')
	else:
		print(s)

	# print('title_width:', title_width)

	if seen:# and not all_seen:
		# show the last *in sequence* episode marked as seen,
		# NOT the episode last *marked* as seen
		if gray:
			print(_f, end='')
		print(f'{ind}Last: ', end='')
		print(format_episode_title('', seen[-1], gray=gray, width=width - 5))

	if print_next and unseen:
		s = format_episode_title('', unseen[0], gray=gray, width=width)
		if s:
			if gray:
				print(_f, end='')
			print(f'{ind}Next:', s)
			print(s)


def series_num_archived(series_config:dict):
	return sum(1 if has_meta('archived', series) else 0 for series in series_config.values())


def get_series(series_config:dict) -> dict:
	series_ids = sorted(series_config, key=lambda series_id: (series_config[series_id]['title'].casefold(), series_config[series_id].get('year', '')))

	series = []
	index = 1

	for series_id in series_ids:
		info = series_config[series_id]

		series.append( (index, series_id, info) )
		index += 1

	return series


def seen_unseen_episodes(series:dict, before=None) -> tuple[list,list]:
	episodes = series.get('episodes', [])
	seen = get_meta(series, 'seen', {})

	seen_eps = []
	unseen_eps = []

	for ep in episodes:
		if _ep_key(ep) in seen:
			seen_eps.append(ep)
		else:
			# only include episodes that are already available in 'unseen'
			dt = ep.get('date')
			if not dt:
				continue
			dt = datetime.fromisoformat(ep.get('date'))
			if before and dt > before:
				continue

			unseen_eps.append(ep)

	return seen_eps, unseen_eps


def term_width() -> int:
	try:
		return int(os.popen('stty size', 'r').read().split()[1])
	except:
		return 100


def option_def(command:str, option:str):
	cmd_opts = known_options.get(command)

	if not cmd_opts:
		return None

	for opt in cmd_opts:
		if option in opt['option']:
			return opt

	return None

def print_cmd_usage(command:str, syntax:str) -> None:
	print(f'Usage: %s {_c}%s{_0} %s' % (PRG, command, syntax))

def options_help(command:str):
	cmd_opts = known_options.get(command)
	if not cmd_opts:
		return []

	return cmd_opts
	opt_help = []
	for opt in cmd_opts:
		option = opt['option']
		opt_help.append( (option, opt['help']) )

	return opt_help


def print_cmd_option_help(command:str) -> None:
	options = options_help(command)
	if options:
		print(f'{_b}Options:{_0}')
		for opt in options:
			option = opt.get('option')
			if type(option) is tuple:
				option = ', '.join(option)

			arg_type = opt.get('arg')
			if arg_type is not None:
				arg_string = arg_placeholder(arg_type)
				option = '%s %s' % (option, arg_string)

			text = opt.get('help', '')
			print('   %-20s %s' % (option, text))


def arg_placeholder(arg_type):
	if arg_type is int:
		return 'N'
	if arg_type is float:
		return 'F'
	if arg_type is datetime:
		return 'YYYY-MM-DD'
	if arg_type is not None:
		return 'string'

	raise RuntimeError('argument placeholder type can not be None')


def print_usage(exit_code:int=0) -> None:
	print(f'{_b}%s{_0} / {_b}Ep{_0}isode {_b}M{_0}anager / (c)2022 André Jonsson' % PRG)
	print('Version %s (%s) ' % (VERSION, VERSION_DATE))
	print(f'{_b}Usage:{_0} %s [{_b}command{_0}] [{_o}<args>{_0}]' % PRG)
	print()
	print(f'Where {_b}<command>{_0} is:  {_f}(one-letter alias highlighted){_0}')
	print(f'  (none)  -> {_b}%s{_0}' % default_command)
	print(f'  {_b}a{_0}dd         Add series')
	print(f'  delete      Delete series (completely remove from config)')
	print(f'  {_b}u{_0}nseen      Show unseen episodes of series')
	print(f'  list        List series')
	print(f'  {_b}m{_0}ark        Mark episode as seen')
	print(f'  un{_b}M{_0}ark      Remove mark, as added by {_b}m{_0}')
	print(f'  {_b}A{_0}rchive     Archive series (still in config, but not normally shown)')
	print(f'  {_b}R{_0}estore     Restore previously archived series')
	print(f'  {_b}r{_0}efresh     Refresh episode data (forcibly)')
	print(f'  {_b}h{_0}elp        Show this help information')
	print()
	print(f'See: %s {_b}<command> --help{_0} for {_b}<args>{_0} help.' % PRG)
	print()
	print('Remarks:')
	print(f'  # = Series listing number, e.g. as listed by the {_b}l{_0}ist command.')
	print(f'  If an argument does not match a command, it will be used as argument to the default command.')
	print(f'  Shortest unique prefix of a command is enough, e.g. "ar"  for "archive".')
	if orjson is not None:
		print(f'  Using {_b}orjson{_0} for faster load/save.')
	else:
		print(f'  {_f}Install \'orjson\' for faster load/save{_0}')
	sys.exit(exit_code)


def print_cmd_help(command:str, exit_code:int=0) -> None:
	try:
		show_help = cmd_handlers[command].help
	except KeyError:
		print('%s: No help for command: %s' % (PRG, command))
		sys.exit(1)

	show_help()
	print_cmd_aliases(command)
	print_cmd_option_help(command)

	sys.exit(exit_code)


def print_cmd_aliases(command:str) -> None:
	for cmd in known_commands:
		if cmd[0] == command and len(cmd) > 1:
			print(f'{_b}Aliases:{_0} %s' % ', '.join(cmd[1:]))
			return


def bad_cmd(cmd:str) -> None:
	print(f'Unknown command: {_E}%s{_0}' % cmd, file=sys.stderr)
	sys.exit(1)

def bad_opt(command:str, option:str) -> None:
	if command:
		print(f'{_c}[{_0}{_b}{PRG} {command}{_c}]{_0} Unknown option: {option}', file=sys.stderr)
	else:
		print(f'{_c}[{PRG}] Unknown option: {option}{_0}', file=sys.stderr)
	sys.exit(1)

def bad_opt_arg(command:str, option, arg, arg_type) -> None:
	if command:
		print(f'{_c}[{_0}{_b}{PRG} {command}{_c}]{_0} ', end='', file=sys.stderr)
	else:
		print(f'{_c}[{_0}{_b}{PRG}{_c}]{_0} ', end='', file=sys.stderr)
	print(f'Bad option argument for {option}: {_b}{arg}{_0}  (%s expected)' % arg_type.__name__, file=sys.stderr)
	sys.exit(1)


def ambiguous_cmd(name:str, matching:str) -> None:
	print(f'Ambiguous command: {_E}%s{_0}  matches: %s' % (name, f'{_o},{_0} '.join(sorted(matching))), file=sys.stderr)
	sys.exit(1)


def now() -> str:
	return now_datetime().isoformat(' ', timespec='seconds')


def now_datetime() -> datetime:
	return datetime.now()


def load_series_config() -> dict:
	config = {}
	if os.path.exists(series_config_file) and os.path.getsize(series_config_file) > 1:
		if orjson is not None:
			with open(series_config_file, 'rb') as fp:
				config = orjson.loads(fp.read())
		else:
			with open(series_config_file, 'r') as fp:
				config = json.load(fp)

	# migrate meta data to new structure
	meta_migrated = 0
	for series_id, series in config.items():
		if not series.get(meta_key):
			legacy_meta_data = {}
			for key in legacy_meta_keys:
				if key in series:
					legacy_meta_data[key] = series.pop(key, None)

			series[meta_key] = legacy_meta_data
			meta_migrated += 1

	if meta_migrated > 0:
		print(f'{_f}Migrated meta-data for %d series{_0}' % meta_migrated)
		save_series_config(config)

	return config


compressor = 'zstd'
compression_extension = '.zst'

import shutil
if not shutil.which(compressor):
	compressor = None
	compression_extension = ''

# TODO: 'mk_backup' should return a waitable promise (so we can do it in parallel with the serialization)
if compressor:
	from subprocess import Popen
	def mk_backup(filename:str, destination:str) -> None:
		tmp_name = mkstemp( dir=os.path.dirname(filename))[1]
		os.rename(filename, tmp_name)
		try:
			exit_code = Popen([compressor, '-18', '-q', '-f', tmp_name, '--rm', '-o', destination]).wait()
			if exit_code != 0:
				os.rename(tmp_name, destination)

		except Exception as e:
			print(f'{_E}ERROR{_0} Failed compressing database backup: %s' % str(e))
			os.rename(tmp_name, destination)
			exit_code = 1

		return exit_code == 0
else:
	def mk_backup(filename:str, destination:str) -> None:
		os.rename(filename, destination)

def save_series_config(config:dict) -> None:
	if not os.path.exists(series_config_file):
		os.makedirs(os.path.dirname(series_config_file), exist_ok=True)

	def backup_name(idx):
		return '%s.%d%s' % (series_config_file, idx, compression_extension)

	# write to a temp file and then rename it afterwards
	tmp_name = mkstemp(dir=os.path.dirname(series_config_file))[1]
	try:
		if orjson is not None:
			with open(tmp_name, 'wb') as fp:
				fp.write(orjson.dumps(config, option=orjson.OPT_INDENT_2 | orjson.OPT_SORT_KEYS))
		else:
			with open(tmp_name, 'w') as fp:
				json.dump(config, fp, indent=2, sort_keys=True)

		# rotate backups
		for idx in range(num_config_backups - 1, 0, -1):
			if os.path.exists(backup_name(idx)):
				os.rename(backup_name(idx), backup_name(idx + 1))

		# current file becomes first backup (<name>.1)
		mk_backup(series_config_file, backup_name(1))

		os.rename(tmp_name, series_config_file)

	except Exception as e:
		print(f'{_E}ERROR{_0} Failed saving series database: %s' % str(e))
		os.remove(tmp_name)


def plural(n:int) -> str:
	if isinstance(n, (list, tuple, dict)):
		n = len(n)
	return '' if n == 1 else 's'

_0 = '\x1b[m'      # normal (reset all)
_0fg = '\x1b[22;23;39m' # normal FG style
_b = '\x1b[1m'     # bold
_g = '\x1b[32;1m'  # good/green
_c = '\x1b[33;1m'  # command
_o = '\x1b[34;1m'  # option
_f = '\x1b[2m'     # faint
_i = '\x1b[3m'     # italic
_fi = '\x1b[2;3m'  # faint & italic
_K = '\x1b[K'      # clear end-of-line
_E = '\x1b[41;97;1m' # ERROR (white on red)

today_date = date.today()

ignore_changes = ('images',)

if __name__ == '__main__':
	try:
		main()
	except tmdb.NoAPIKey:
		print('No TMDb API key.', file=sys.stderr)
		print(tmdb.api_key_help)
		sys.exit(0)
	except KeyboardInterrupt:
		print('** User beak', file=sys.stderr)
		sys.exit(1)
